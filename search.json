[{"path":"https://mathurlabstanford.github.io/phacking/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 phacking authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://mathurlabstanford.github.io/phacking/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Maya Mathur. Author, maintainer. Mika Braginsky. Author.","code":""},{"path":"https://mathurlabstanford.github.io/phacking/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Mathur M, Braginsky M (2023). phacking: Sensitivity Analysis p-Hacking Meta-Analyses. https://github.com/mathurlabstanford/phacking, https://mathurlabstanford.github.io/phacking.","code":"@Manual{,   title = {phacking: Sensitivity Analysis for p-Hacking in Meta-Analyses},   author = {Maya Mathur and Mika Braginsky},   year = {2023},   note = {https://github.com/mathurlabstanford/phacking, https://mathurlabstanford.github.io/phacking}, }"},{"path":"https://mathurlabstanford.github.io/phacking/index.html","id":"phacking","dir":"","previous_headings":"","what":"Sensitivity Analysis for p-Hacking in Meta-Analyses","title":"Sensitivity Analysis for p-Hacking in Meta-Analyses","text":"phacking R package provides bias correction joint effects p-hacking (.e., manipulation results within studies obtain significant, positive estimates) traditional publication bias (.e., selective publication studies significant, positive results) meta-analyses (per Mathur, 2022).","code":""},{"path":"https://mathurlabstanford.github.io/phacking/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Sensitivity Analysis for p-Hacking in Meta-Analyses","text":"can install phacking CRAN : can install development version phacking GitHub : may also need install Stan.","code":"install.packages(\"phacking\") # install.packages(\"devtools\") devtools::install_github(\"mathurlabstanford/phacking\")"},{"path":"https://mathurlabstanford.github.io/phacking/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Sensitivity Analysis for p-Hacking in Meta-Analyses","text":"Fit bias-corrected meta-analysis example dataset package.","code":"library(phacking) phacking_meta(money_priming_meta$yi, money_priming_meta$vi)"},{"path":"https://mathurlabstanford.github.io/phacking/reference/money_priming_meta.html","id":null,"dir":"Reference","previous_headings":"","what":"Meta-analysis of money priming studies — money_priming_meta","title":"Meta-analysis of money priming studies — money_priming_meta","text":"Dataset meta-analysis experimental studies effect money primes variety psychological behavioral outcomes, studies preregistered (Lodder et al. 2019) .","code":""},{"path":"https://mathurlabstanford.github.io/phacking/reference/money_priming_meta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Meta-analysis of money priming studies — money_priming_meta","text":"","code":"money_priming_meta"},{"path":"https://mathurlabstanford.github.io/phacking/reference/money_priming_meta.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Meta-analysis of money priming studies — money_priming_meta","text":"data frame 287 rows 4 variables: study Code identifying study yi Point estimate Hedges' g scale vi Variance point estimate zi Z-score preregistered Logical indicating whether study preregistered","code":""},{"path":"https://mathurlabstanford.github.io/phacking/reference/money_priming_meta.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Meta-analysis of money priming studies — money_priming_meta","text":"Lodder P, Ong HH, Grasman RPPP, Wicherts JM (2019). “comprehensive meta-analysis money priming.” Journal Experimental Psychology: General, 148(4), 688. Lodder P, Ong HH, Grasman RPPP, Wicherts JM (2020). “comprehensive meta-analysis money priming.” OSF. https://osf.io/dhp63.","code":""},{"path":"https://mathurlabstanford.github.io/phacking/reference/phacking-package.html","id":null,"dir":"Reference","previous_headings":"","what":"phacking: Sensitivity Analysis for p-Hacking in Meta-Analyses — phacking-package","title":"phacking: Sensitivity Analysis for p-Hacking in Meta-Analyses — phacking-package","text":"Fits right-truncated meta-analysis (RTMA), bias correction joint effects p-hacking (.e., manipulation results within studies obtain significant, positive estimates) traditional publication bias (.e., selective publication studies significant, positive results) meta-analyses [see Mathur MB (2022). \"Sensitivity analysis p-hacking meta-analyses.\" doi:10.31219/osf.io/ezjsx .]. Unlike publication bias alone, p-hacking favors significant, positive results (termed \"affirmative\") can distort distribution affirmative results. bias-correct results affirmative studies require strong assumptions exact nature p-hacking. contrast, joint p-hacking publication bias distort distribution published nonaffirmative results stringent p-hacking (e.g., investigators hack always eventually obtain affirmative result) stringent publication bias (e.g., nonaffirmative results hacked studies never published). means published nonaffirmative results unhacked studies. assumptions, RTMA involves analyzing published nonaffirmative results essentially impute full underlying distribution results prior selection due p-hacking /publication bias. package also provides diagnostic plots described Mathur (2022).","code":""},{"path":"https://mathurlabstanford.github.io/phacking/reference/phacking-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"phacking: Sensitivity Analysis for p-Hacking in Meta-Analyses — phacking-package","text":"Mathur MB (2022). “Sensitivity analysis p-hacking meta-analyses.” doi:10.31219/osf.io/ezjsx . Lodder P, Ong HH, Grasman RPPP, Wicherts JM (2019). “comprehensive meta-analysis money priming.” Journal Experimental Psychology: General, 148(4), 688. Stan Development Team (2022). “RStan: R interface Stan.” R package version 2.21.5. https://mc-stan.org.","code":""},{"path":[]},{"path":"https://mathurlabstanford.github.io/phacking/reference/phacking-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"phacking: Sensitivity Analysis for p-Hacking in Meta-Analyses — phacking-package","text":"Maintainer: Mika Braginsky mika.br@gmail.com Authors: Maya Mathur mmathur@stanford.edu","code":""},{"path":"https://mathurlabstanford.github.io/phacking/reference/phacking_meta.html","id":null,"dir":"Reference","previous_headings":"","what":"Right-truncated meta-analysis — phacking_meta","title":"Right-truncated meta-analysis — phacking_meta","text":"Fits right-truncated meta-analysis (RTMA), bias correction joint effects p-hacking (.e., manipulation results within studies obtain significant, positive estimates) traditional publication bias (.e., selective publication studies significant, positive results) meta-analyses.","code":""},{"path":"https://mathurlabstanford.github.io/phacking/reference/phacking_meta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Right-truncated meta-analysis — phacking_meta","text":"","code":"phacking_meta(   yi,   vi,   sei,   favor_positive = TRUE,   alpha_select = 0.05,   ci_level = 0.95,   stan_control = list(adapt_delta = 0.98, max_treedepth = 20),   parallelize = TRUE )"},{"path":"https://mathurlabstanford.github.io/phacking/reference/phacking_meta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Right-truncated meta-analysis — phacking_meta","text":"yi vector point estimates meta-analyzed. vi vector estimated variances (.e., squared standard errors) point estimates. sei vector estimated standard errors point estimates. (one vi sei needs specified). favor_positive TRUE publication bias assumed favor significant positive estimates; FALSE assumed favor significant negative estimates. alpha_select Alpha level estimate's probability favored publication bias assumed change (.e., threshold study investigators, journal editors, etc., consider estimate significant). ci_level Confidence interval level (proportion) corrected point estimate. (alpha level inference corrected point estimate calculated ci_level.) stan_control List passed rstan::sampling() control argument. parallelize Logical indicating whether parallelize sampling.","code":""},{"path":"https://mathurlabstanford.github.io/phacking/reference/phacking_meta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Right-truncated meta-analysis — phacking_meta","text":"object class metabias::metabias(), list containing: data tibble one row per study columns yi, vi, sei, affirm. values list elements favor_positive, alpha_select, ci_level, tcrit, k, k_affirmative, k_nonaffirmative, optim_converged. optim_converged indicates whether optimization find posterior mode converged. stats tibble two rows columns param, mode, median, mean, se, ci_lower, ci_upper, n_eff, r_hat. recommend reporting mode point estimate; median mean represent posterior medians means respectively. fit stanfit object (result fitting RTMA model).","code":""},{"path":"https://mathurlabstanford.github.io/phacking/reference/phacking_meta.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Right-truncated meta-analysis — phacking_meta","text":"Mathur MB (2022). “Sensitivity analysis p-hacking meta-analyses.” doi:10.31219/osf.io/ezjsx .","code":""},{"path":"https://mathurlabstanford.github.io/phacking/reference/phacking_meta.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Right-truncated meta-analysis — phacking_meta","text":"","code":"# \\donttest{ money_priming_rtma <- phacking_meta(money_priming_meta$yi, money_priming_meta$vi,                                     parallelize = FALSE) #>  #> SAMPLING FOR MODEL 'phacking_rtma' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 0.000488 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 4.88 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 4.509 seconds (Warm-up) #> Chain 1:                3.99 seconds (Sampling) #> Chain 1:                8.499 seconds (Total) #> Chain 1:  #>  #> SAMPLING FOR MODEL 'phacking_rtma' NOW (CHAIN 2). #> Chain 2:  #> Chain 2: Gradient evaluation took 0.000367 seconds #> Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 3.67 seconds. #> Chain 2: Adjust your expectations accordingly! #> Chain 2:  #> Chain 2:  #> Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 2:  #> Chain 2:  Elapsed Time: 4.38 seconds (Warm-up) #> Chain 2:                3.56 seconds (Sampling) #> Chain 2:                7.94 seconds (Total) #> Chain 2:  #>  #> SAMPLING FOR MODEL 'phacking_rtma' NOW (CHAIN 3). #> Chain 3:  #> Chain 3: Gradient evaluation took 0.000351 seconds #> Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 3.51 seconds. #> Chain 3: Adjust your expectations accordingly! #> Chain 3:  #> Chain 3:  #> Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 3:  #> Chain 3:  Elapsed Time: 3.988 seconds (Warm-up) #> Chain 3:                4.538 seconds (Sampling) #> Chain 3:                8.526 seconds (Total) #> Chain 3:  #>  #> SAMPLING FOR MODEL 'phacking_rtma' NOW (CHAIN 4). #> Chain 4:  #> Chain 4: Gradient evaluation took 0.000348 seconds #> Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 3.48 seconds. #> Chain 4: Adjust your expectations accordingly! #> Chain 4:  #> Chain 4:  #> Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 4:  #> Chain 4:  Elapsed Time: 4.034 seconds (Warm-up) #> Chain 4:                3.907 seconds (Sampling) #> Chain 4:                7.941 seconds (Total) #> Chain 4:  # }"},{"path":"https://mathurlabstanford.github.io/phacking/reference/rtma_cdf.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute theoretical and empirical CDFs for a right-truncated meta-analysis — rtma_cdf","title":"Compute theoretical and empirical CDFs for a right-truncated meta-analysis — rtma_cdf","text":"Compute theoretical empirical CDFs right-truncated meta-analysis","code":""},{"path":"https://mathurlabstanford.github.io/phacking/reference/rtma_cdf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute theoretical and empirical CDFs for a right-truncated meta-analysis — rtma_cdf","text":"","code":"rtma_cdf(rtma)"},{"path":"https://mathurlabstanford.github.io/phacking/reference/rtma_cdf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute theoretical and empirical CDFs for a right-truncated meta-analysis — rtma_cdf","text":"rtma Output phacking_meta().","code":""},{"path":"https://mathurlabstanford.github.io/phacking/reference/rtma_cdf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute theoretical and empirical CDFs for a right-truncated meta-analysis — rtma_cdf","text":"tibble columns yi (effect sizes), cdfi (fitted CDF) ecdfi (empirical CDF).","code":""},{"path":"https://mathurlabstanford.github.io/phacking/reference/rtma_cdf.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute theoretical and empirical CDFs for a right-truncated meta-analysis — rtma_cdf","text":"Mathur MB (2022). “Sensitivity analysis p-hacking meta-analyses.” doi:10.31219/osf.io/ezjsx .","code":""},{"path":"https://mathurlabstanford.github.io/phacking/reference/rtma_cdf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute theoretical and empirical CDFs for a right-truncated meta-analysis — rtma_cdf","text":"","code":"# \\donttest{ money_priming_rtma <- phacking_meta(money_priming_meta$yi,                                     money_priming_meta$vi,                                     parallelize = FALSE) #>  #> SAMPLING FOR MODEL 'phacking_rtma' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 0.000405 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 4.05 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 4.347 seconds (Warm-up) #> Chain 1:                3.948 seconds (Sampling) #> Chain 1:                8.295 seconds (Total) #> Chain 1:  #>  #> SAMPLING FOR MODEL 'phacking_rtma' NOW (CHAIN 2). #> Chain 2:  #> Chain 2: Gradient evaluation took 0.00038 seconds #> Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 3.8 seconds. #> Chain 2: Adjust your expectations accordingly! #> Chain 2:  #> Chain 2:  #> Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 2:  #> Chain 2:  Elapsed Time: 4.647 seconds (Warm-up) #> Chain 2:                3.958 seconds (Sampling) #> Chain 2:                8.605 seconds (Total) #> Chain 2:  #>  #> SAMPLING FOR MODEL 'phacking_rtma' NOW (CHAIN 3). #> Chain 3:  #> Chain 3: Gradient evaluation took 0.00035 seconds #> Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 3.5 seconds. #> Chain 3: Adjust your expectations accordingly! #> Chain 3:  #> Chain 3:  #> Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 3:  #> Chain 3:  Elapsed Time: 4.654 seconds (Warm-up) #> Chain 3:                3.603 seconds (Sampling) #> Chain 3:                8.257 seconds (Total) #> Chain 3:  #>  #> SAMPLING FOR MODEL 'phacking_rtma' NOW (CHAIN 4). #> Chain 4:  #> Chain 4: Gradient evaluation took 0.000347 seconds #> Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 3.47 seconds. #> Chain 4: Adjust your expectations accordingly! #> Chain 4:  #> Chain 4:  #> Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 4:  #> Chain 4:  Elapsed Time: 4.07 seconds (Warm-up) #> Chain 4:                3.604 seconds (Sampling) #> Chain 4:                7.674 seconds (Total) #> Chain 4:  rtma_cdf(money_priming_rtma) #> # A tibble: 174 × 3 #>          yi  cdfi  ecdfi #>       <dbl> <dbl>  <dbl> #>  1  0.650   0.972 0.994  #>  2 -0.416   0.133 0.0517 #>  3 -0.527   0.108 0.0287 #>  4  0.0618  0.689 0.592  #>  5  0.0735  0.566 0.609  #>  6  0.397   0.956 0.948  #>  7  0.153   0.696 0.718  #>  8 -0.0962  0.306 0.316  #>  9 -0.00654 0.458 0.471  #> 10  0.175   0.797 0.747  #> # ℹ 164 more rows # }"},{"path":"https://mathurlabstanford.github.io/phacking/reference/rtma_qqplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Diagnostic quantile-quantile plot for a right-truncated meta-analysis — rtma_qqplot","title":"Diagnostic quantile-quantile plot for a right-truncated meta-analysis — rtma_qqplot","text":"assess fit right-truncated meta-analysis possible violations distributional assumptions, plots fitted cumulative distribution function (CDF) published nonaffirmative estimates versus empirical CDF. points adhere fairly closely 45-degree line, right-truncated meta-analysis may fit adequately.","code":""},{"path":"https://mathurlabstanford.github.io/phacking/reference/rtma_qqplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Diagnostic quantile-quantile plot for a right-truncated meta-analysis — rtma_qqplot","text":"","code":"rtma_qqplot(rtma)"},{"path":"https://mathurlabstanford.github.io/phacking/reference/rtma_qqplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Diagnostic quantile-quantile plot for a right-truncated meta-analysis — rtma_qqplot","text":"rtma Output phacking_meta().","code":""},{"path":"https://mathurlabstanford.github.io/phacking/reference/rtma_qqplot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Diagnostic quantile-quantile plot for a right-truncated meta-analysis — rtma_qqplot","text":"","code":"# \\donttest{ money_priming_rtma <- phacking_meta(money_priming_meta$yi,                                     money_priming_meta$vi,                                     parallelize = FALSE) #>  #> SAMPLING FOR MODEL 'phacking_rtma' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 0.000404 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 4.04 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 4.118 seconds (Warm-up) #> Chain 1:                3.357 seconds (Sampling) #> Chain 1:                7.475 seconds (Total) #> Chain 1:  #>  #> SAMPLING FOR MODEL 'phacking_rtma' NOW (CHAIN 2). #> Chain 2:  #> Chain 2: Gradient evaluation took 0.000382 seconds #> Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 3.82 seconds. #> Chain 2: Adjust your expectations accordingly! #> Chain 2:  #> Chain 2:  #> Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 2:  #> Chain 2:  Elapsed Time: 4.603 seconds (Warm-up) #> Chain 2:                3.672 seconds (Sampling) #> Chain 2:                8.275 seconds (Total) #> Chain 2:  #>  #> SAMPLING FOR MODEL 'phacking_rtma' NOW (CHAIN 3). #> Chain 3:  #> Chain 3: Gradient evaluation took 0.000351 seconds #> Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 3.51 seconds. #> Chain 3: Adjust your expectations accordingly! #> Chain 3:  #> Chain 3:  #> Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 3:  #> Chain 3:  Elapsed Time: 4.787 seconds (Warm-up) #> Chain 3:                4.032 seconds (Sampling) #> Chain 3:                8.819 seconds (Total) #> Chain 3:  #>  #> SAMPLING FOR MODEL 'phacking_rtma' NOW (CHAIN 4). #> Chain 4:  #> Chain 4: Gradient evaluation took 0.000349 seconds #> Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 3.49 seconds. #> Chain 4: Adjust your expectations accordingly! #> Chain 4:  #> Chain 4:  #> Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup) #> Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup) #> Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup) #> Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup) #> Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup) #> Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling) #> Chain 4:  #> Chain 4:  Elapsed Time: 4.152 seconds (Warm-up) #> Chain 4:                3.259 seconds (Sampling) #> Chain 4:                7.411 seconds (Total) #> Chain 4:  rtma_qqplot(money_priming_rtma)  # }"},{"path":"https://mathurlabstanford.github.io/phacking/reference/z_density.html","id":null,"dir":"Reference","previous_headings":"","what":"Z-score density plot — z_density","title":"Z-score density plot — z_density","text":"Plots Z-scores published point estimates. p-hacking favors affirmative estimates nonaffirmative estimates, methods others assume, Z-scores may disproportionately concentrate just critical value (e.g., 1.96). Importantly, presence p-hacking guarantee concentration Z-scores just critical value, prudent proceed fitting RTMA even concentration apparent. contrast, Z-scores also concentrate just critical value, also concentrate sign-reversed critical value (e.g., -1.96), indicate forms p-hacking violate assumptions RTMA.","code":""},{"path":"https://mathurlabstanford.github.io/phacking/reference/z_density.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Z-score density plot — z_density","text":"","code":"z_density(yi, vi, sei, alpha_select = 0.05, crit_color = \"red\")"},{"path":"https://mathurlabstanford.github.io/phacking/reference/z_density.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Z-score density plot — z_density","text":"yi vector point estimates meta-analyzed. vi vector estimated variances (.e., squared standard errors) point estimates. sei vector estimated standard errors point estimates. (one vi sei needs specified). alpha_select Alpha level estimate's probability favored publication bias assumed change (.e., threshold study investigators, journal editors, etc., consider estimate significant). crit_color Color line text critical z-score.","code":""},{"path":"https://mathurlabstanford.github.io/phacking/reference/z_density.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Z-score density plot — z_density","text":"","code":"z_density(money_priming_meta$yi, money_priming_meta$vi)"},{"path":[]},{"path":"https://mathurlabstanford.github.io/phacking/news/index.html","id":"phacking-010","dir":"Changelog","previous_headings":"","what":"phacking 0.1.0","title":"phacking 0.1.0","text":"CRAN release: 2023-01-20 Function argument names consistent related packages. Components common related packages come metabias package (@param docs, returned object structure/class, references).","code":""}]
